## 1. HashMap的原理

`HashMap`是Java存储键值对的数据结构，它的底层实现是使用哈希表来，通过将键的哈希值映射到数组索引上来实现哈希搜索，然后数组的每个节点都对应一个链表来处理哈希冲突。

哈希值的获取是通过键值元素的`hashCode()`方法来实现

`HashMap`的默认容量为16，负载因子为0.75，也就是说当元素数量超过 16 * 0.75 = 12 时就会触发扩容，将容量 * 2 并重新分配元素位置，频繁的扩容很容易影响性能。

### 红黑树优化

从Java 8 开始，为了优化多个元素映射到同一个哈希桶时的查找性能，当链表长度大于等于8，且数组长度大于等于64时时，链表就会转换为红黑树。

红黑树是一种自平衡二叉树，相比于平衡二叉树，它在执行插入节点和删除节点时性能更好。

能够将最坏情况的时间复杂度从O(n)降低到O(logn)

当树中元素数量低于6时，红黑树就会退化会链表，减少不必要的开销。

### 为什么一个是8，一个是6呢

这是为了防止对同一数组节点的反复插入和删除。刚退化为链表就插入，刚转换为红黑树就删除。

### 为什么数组大于等于64

因为数组容量小时，虽然哈希冲突大，但是在扩容后自然会减小哈希冲突。如果在小数组上过早的进行链表转红黑树，可能会因为很快的扩容而导致不必要的开销，刚树化没多久就扩容重定位了。

红黑树相比于链表要占用更多的内存。在节点数量较少的情况下，红黑树的额外指针和结构占用更大。

### hashCode() 和 equals()

`HashMap`通过`hashCode()`来获取哈希值，通过`equals()`比较两个键是否相同。在`put()`时，如果两个键的`hashCode()`，而`equals()`返回`false`，则会被视为两个不同的键，放在同一个数组节点的链表上。

### 哈希表

在 JKD 1.7 及以前，链表的插入采用的是头插法。

头插法在多线程环境下，可能会导致链表形成环，特别是在并发扩容时。当多个线程执行`put()`时，如果线程A在头插，线程B也在同一时刻操作链表，可能会导致链表结构出现环路，引发死循环，最终导致程序卡死或无限循环。

假如此时线程1 和 2 同时在插入，都出发了扩容

```java
void transfer(Entry[] newTable) {
  Entry[] src = table; 
  int newCapacity = newTable.length;
  for (int j = 0; j < src.length; j++) { 
      Entry<K,V> e = src[j];           
      if (e != null) {
          src[j] = null; 
          do { 
              Entry<K,V> next = e.next; 
             int i = indexFor(e.hash, newCapacity);//线程1执行到这没cpu时间片，线程2继续执行
             e.next = newTable[i]; 
             newTable[i] = e;  
             e = next;             
         } while (e != null);
     }
 }
}
```

此时线程1创建了节点，并计算完成了next的索引。但此时时间片到了，线程2开始执行，并成功扩容

从 JDK 1.8 开始，改为了尾插法，保持插入的从顺序，并且引入了红黑树。

## 2. ConcurrentHashMap 1.7 和 1.8 有什么区别

## 3. JDK 1.8 对 HashMap 除了红黑树还进行了哪些改动

- 改进了哈希函数的计算

  优化了哈希函数，使得哈希值的分布更加均匀，减少了哈希冲突的发生。通过在生成哈希值时使用“扰动函数”，确保哈希值的高低位都能参与到桶的选择中。

- 扩容机制优化

  改进了元素迁移机制，扩容过程中不再对每个元素都重新计算哈希值，而是根据原数组长度的高位来判断元素是留在原位置还是迁移到新数组中的新位置。

- 头插法改为尾插法

  头插法的好处是插入时不需要遍历链表，但缺点是扩容时会逆序，而逆序在多线程操作下可能会出现环、死循环等问题。

### 哈希函数

```java
static int hash(int h) { // 1.7
    h ^= (h >>> 20) ^ (h >>> 12);
    return h ^ (h >>> 7) ^ (h >>> 4);
}
static final int hash(Object key) {// 1.8
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

这样哈希分布更均匀

### 扩容机制优化

在JDK1.7中，扩容是对每个元素都重新计算哈希

在1.8中，数组的长度总是2的次方，且扩容两倍。因此数组长度的二进制表示仅为1左移了一位

在通过哈希值定位时采用的方法是`(数组长度 - 1) & hash`。

所以哈希值如果在数组长度新增的1位上为0，那么它一定不需要移动。

### 头插法改为尾插法

## 4. Java 中有哪些集合类

Java中的集合类主要分为两大类：Collection和Map。一个存储对象，一个存储键值对

Collection接口又分为List、Set、Queue接口

### List

- ArrayList

  动态数组，查询速度快，插入、删除慢

- LinkedList

  双向链表，插入、删除快，查询慢

- Vector

  线程安全的动态数组

### Set

- HashSet

  基于哈希表，元素无序，不允许重复

- LinkedHashSet

  基于链表和哈希表，维护插入顺序，不允许重复

- TreeSet

  基于红黑树，元素有序，不允许重复

### Queue

- PriorityQueue

  基于优先级堆，元素按照自然顺序或指定比较器顺序排序

- LinkedList

  可以作为队列使用，支持FIFO操作

### Map

- HashMap

  基于哈希表，不允许键重复

- LinkedHashMap

  基于链表和哈希表，维护插入顺序

- TreeMap

  基于红黑树，键有序

- Hashtable

  线程安全的哈希表

- ConcurrentHashMap

  线程安全的哈希表，适合高并发环境

